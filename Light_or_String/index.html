<doctype html>
<!-- Copyright 2020, Cem Yuksel, University of Utah -->
<html>
<head>
<title>Light or Sting</title>


<!-- ── Sphere mesh ------------------------------------------------------- -->
<script id="sphereVS" type="x-shader/x-vertex">
attribute vec3 p;      // sphere vertex on a unit sphere
uniform mat4  mvp;     // model-view-projection matrix
uniform vec3  center;  // sphere center (world)
uniform float radius;  // sphere radius
varying vec3 pos;      // world-space position (to fragment)
varying vec3 normal;   // world-space normal (to fragment)
void main() {
    pos = p*radius + center;         // scale & translate unit sphere
    gl_Position = mvp * vec4(pos,1); // to clip space
    normal = p;                      // unit-sphere normal = position on unit sphere
}
</script>


<script id="sphereFS" type="x-shader/x-fragment">
// adapted from project6 to be used for multiple light sources
precision mediump float;

// k_d: diffuse, k_s: specular, n: shininess (Phong exponent)
struct Material { vec3 k_d; vec3 k_s; float n; };
struct Light    { vec3 position; vec3 intensity; float radius; };

uniform samplerCube envMap; // cubemap for reflections
uniform Light    lights[NUM_LIGHTS];
uniform vec3     campos;    // camera position (world)
uniform Material mtl;       // material params

varying vec3 pos;           // from vertex shader
varying vec3 normal;        // from vertex shader

void main()
{
    vec3 nrm   = normalize(normal);
    vec3 view  = normalize(campos - pos);
    vec3 color = vec3(0.0);

    /* Blinn–Phong from every light ----------------------------- */
    for (int i = 0; i < NUM_LIGHTS; ++i) {
        vec3 L = normalize(lights[i].position - pos);
        float c = max(dot(nrm, L), 0.0);
        if (c > 0.0) {
            vec3 h   = normalize(L + view);
            float s  = pow(max(dot(nrm, h), 0.0), mtl.n);
            color   += (mtl.k_d * c + mtl.k_s * s) * lights[i].intensity;
        }
    }

    /* environment-map reflection ------------------------------- */
    if (mtl.k_s.r + mtl.k_s.g + mtl.k_s.b > 0.0) {
        vec3 refl = reflect(-view, nrm);    // perfect mirror direction
        color += mtl.k_s * textureCube(envMap, refl.xzy).rgb; // reflectivity
    }
    gl_FragColor = vec4(color, 1.0);
}
</script>

<!-- ── Full-screen ray-gen quad (env map) ------------------------------- -->
<script id="envRaytraceVS" type="x-shader/x-vertex">
attribute vec3 p;      // position in camera space plane
uniform   mat4 proj;   // projection matrix (P)
uniform   mat4 c2w;    // camera-to-world matrix ( = V^{-1} )
varying   vec3 ray_pos;// world ray origin
varying   vec3 ray_dir;// world ray direction
void main() {
    gl_Position = proj * vec4(p,1);       // draw the screen-plane triangle(s)
    vec4 rp = c2w * vec4(0,0,0,1);        // camera origin in world space
    ray_pos = rp.xyz;
    vec4 rd = c2w * vec4(p,1);            // a point on the camera plane in world
    ray_dir = rd.xyz - ray_pos;           // direction for this pixel
}
</script>

<script id="envFS" type="x-shader/x-fragment">
precision mediump float;
varying vec3 ray_dir;
uniform samplerCube envMap;
void main() {
    gl_FragColor = textureCube(envMap, ray_dir.xzy); // sample cubemap
}
</script>

<script id="glowVS" type="x-shader/x-vertex">
attribute vec3 p;        // vertex in the object's local space (often unit sphere)
uniform   mat4 mvp;      // P * V * M (projection * view * model)
uniform   vec3 center;   // world-space center of the glow volume
uniform   float scale;   // uniform radius scale for the mesh
varying   float d;       // passes a distance-like value to the fragment shader
void main() {
    vec3 pos = p * scale + center;      // MODEL: scale the local vertex and translate to world
    gl_Position = mvp * vec4(pos,1.0);  // to clip space (P*V*M)
    d = length(p) * scale;              // object-space radius at this vertex (≈ distance to center)
}
</script>

<script id="glowFS" type="x-shader/x-fragment">
precision mediump float;
varying float d;         // interpolated per pixel
uniform vec3  glowColor; // RGB of the glow
uniform float radius;    // falloff outer radius (in the same units as 'd')
uniform float gamma;     // inner-core factor (0..1), controls softness width
uniform float intensity; // overall opacity scale

void main() {
    float a = smoothstep(radius*gamma, radius, d);
    gl_FragColor = vec4(glowColor, (1.0 - a) * intensity);
}
</script>

<head>
  <link rel="stylesheet" href="styles.css">
</head>
</head>
<script src="utils.js"></script>
<script src="meshDrawer.js"></script>
<script src="obj.js"></script>
<script src="flyers.js"></script>
<script src="projectile.js"></script>
<script src="ray.js"></script>
<script src="sphere.js"></script>
<script src="init.js"></script>
<script src="main.js"></script>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas><canvas id="overlay"></canvas></div><div id="controls-div">
<div id="score">Score: 0</div>
<div id="controls">
<div class="control-group">
<div class="control"><hr/></div>
<div class="control">
  <label for="firefly-input">Firefly Count:</label>
  <input type="number" id="firefly-input" min="0" max="20" value="3">
</div>
<div class="control">
  <label for="hornet-input">Hornet Count:</label>
  <input type="number" id="hornet-input" min="0" max="20" value="3">
</div>
<div class="control"><input type="button" class="btn" value="Start" onclick="NewScene()"></div>
</div>
</div>
</div>
</div>
</body>
</html>